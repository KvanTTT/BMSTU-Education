// Format Output on C++.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <strstream>    //  в этом заголовочном файле описан ostrstream
#include <iostream>
#include "conio.h"
#include <iomanip>

using namespace std;

#define MAX_LENGTH 20   

void row (void);     // прототип функции вывода номера строки

void main()
{
  char c = 'A', psz[] = "It is a string for experiments",
  strbuffer[MAX_LENGTH];      // резервирование памяти
  int value = 1234, w;
  double dpi = 3.14159265;

// Выполните следующие действия:

// вывод символа с
	row();
	cout << c;

// вывод ASCII-кода символа с
	row();
	cout << (int)c;


// вывод символа c ASCII-кодом 90
	row();
	cout << (char)90;

// вывод значения переменной ivalue в восьмеричной системе
	row();
	cout.setf(ios::oct, ios::basefield);
	cout << value;
   
// вывод значения переменной ivalue в шестнадцатеричной системе с буквами в нижнем           
// регистре
	row();
	cout.setf(ios::hex, ios::basefield);
	cout << value;
	cout.setf(ios::dec, ios::basefield);
   
// вывод значения переменной ivalue в шестнадцатеричной системе с буквами в верхнем           
// регистре
	row();
	cout.setf(ios::uppercase);
	cout << value;

// вывод одного символа, минимальная ширина поля равна 5, выравнивание  вправо      
// с дополнением пробелами
	row();
	cout.fill(' ');
	cout.width(5);
	cout << c;

// вывод одного символа, минимальная ширина поля равна 5, выравнивание  влево      
// с дополнением пробелами
	row();
	cout << left << c;

// вывод строки, отображаются 30 символов
	row();
	cout << setw(30) << psz;

// вывод минимум пяти символов
	row();
	cout << setw(5) << psz;


// вывод минимум 38 символов строки, выравнивание вправо с дополнением пробелами
	row();
	cout << setw(38) << right << psz;

// вывод минимум 38 символов строки, выравнивание влево с дополнением пробелами
	row();
	cout << setw(38) << left << psz;

// вывод значения ivalue, по умолчанию отображаются 4 цифры
	row();
	cout << setw(4) << value;

// вывод значения ivalue со знаком
	row();
	cout << showpos << value;
	cout.unsetf(ios::showpos);

// задание вывода значения ivalue минимум из 3 цифр, а на самом деле запрос будет    
// проигнорирован и отобразятся 4 цифры 
	row();
	cout.fill(' ');
	cout.width(3);
	cout << value;


// вывод значения ivalue минимум из 10 цифр, выравнивание вправо с дополнением    
// пробелами
	row();
	cout.width(10);
	cout << right << value;

// вывод значения ivalue минимум из 10 цифр, выравнивание влево с дополнением    
// пробелами
	row();
	cout << left << value;
   
// вывод значения ivalue минимум из 10 цифр, выравнивание вправо с дополнением    
// нулями
	row();
	cout.fill('0');
	cout.width(10);
	cout << right << value;

// вывод значения dpi с форматированием по умолчанию
	row();
	cout << dpi;

// Задержка экрана! для того, чтобы успеть рассмотреть первую часть информации на 
// экране
   cout << "\n Please, input any letter or number to continue \n";
   cin >> w;
   cout << "\n";

// вывод значения dpi, минимальная ширина поля равна 20, выравнивание  вправо      
// с дополнением пробелами
   row();
   cout.width(20);
   cout.fill(' ');
   cout << right << dpi;

// вывод значения dpi, минимальная ширина поля равна 20, выравнивание  вправо      
// с дополнением нулями
   row();
   cout.width(20);
   cout.fill('0');
   cout << right << dpi;

// вывод значения dpi, минимальная ширина поля равна 20, выравнивание  влево      
// с дополнением пробелами
   row();
   cout.fill(' ');
   cout.width(20);
   cout << left << dpi;

// вывод значения dpi, минимальная ширина поля равна 20, выравнивание  влево      
// с дополнением нулями
   row();
   cout.fill('0');
   cout.width(20);
   cout << left << dpi;

// вывод 19 символов строки, минимальная ширина поля равна 19
   row();    // [24]
   ostrstream (strbuffer, 20).write(psz, 19) << ends;
/*Здесь используются понятия класса и конструктора класса. Флаги форматирования    
   оказывают влияние на работу оператора <<, но функция write () всегда записывает   
   указанное количество символов с выравниванием влево. Чтобы это изменить,    
   определяют буферную строку и с ней проводят все необходимые  манипуляции
*/
   cout.width (19);
   cout << strbuffer;

// вывод первых двух символов строки, так как третий - \0 (признак конца строки)
   row();    // [25]
   ostrstream(strbuffer, 3).write(psz, 2) << ends;
   cout << strbuffer;

// вывод первых двух символов строки, минимальная ширина поля равна 19,  
// выравнивание  вправо с дополнением пробелами
   row();
   ostrstream(strbuffer, 20).write(psz, 2) << ends;
   cout.fill(' ');
   cout << setw(20) << right << strbuffer;

// вывод первых двух символов строки, минимальная ширина поля равна 19, 
// выравнивание  влево с дополнением пробелами
   row();
   cout.fill(' ');
   ostrstream(strbuffer, 20).write(psz, 2) << ends;
   cout << setw(20) << left << strbuffer;

// вывод значения dpi из 9 значащих цифр
   row();
   cout.precision(9);
   cout << dpi;
   

// вывод значения dpi из 2 значащих цифр, минимальная ширина поля равна 20,  
// выравнивание  вправо с дополнением пробелами
   row();
   cout.precision(2);
   cout.width(20);
   cout << right << dpi;

// вывод значения dpi из 4 значащих цифр 
   row();
   cout.precision(4);
   cout << dpi;

// вывод значения dpi из 4 значащих цифр, минимальная ширина поля равна 20, 
// выравнивание  вправо с дополнением пробелами
   row();
   cout.precision(4);
   cout.width(20);
   cout << right << dpi;

// вывод значения dpi, минимальная ширина поля равна 20, 4 цифры после десятичной 
// точки,  выравнивание  вправо с дополнением пробелами, научный формат 
    row();
	cout.width(20);
	cout << setprecision(4) << scientific << right << dpi;

   getch();

 }
   

void row (void)
{
  static int ln = 0;    /* Переменная ln объявлена как static, поэтому при повторном вызове   
                                   функции row () у переменной ln сохраняется ее последнее значение 
                                   для того, чтобы программа «помнила» номер предыдущей строки
                                   вывода*/
	cout << "\n [";
	cout.width (2);
	cout <<++ln << "] ";
}







